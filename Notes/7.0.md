---
date: 
tags: 
note quality: 
mooc link: 
note links: 
finished:
---
________________________
# Introduction to Operating Systems

## Module Outline
*   **Operating Systems**
*   **Memory**
*   **Architecture**

## Operating System Definition
An Operating System (OS):
*   **Exploits the hardware resources of one or more processors**.
*   **Provides a set of services to system users**.
*   **Manages secondary memory and I/O devices**.

## Basic Elements of a Computer System
*   **Processor (Central Processing Unit - CPU)**: Controls computer operation and performs data processing.
*   **Main Memory**: Stores data and programs.  Volatile (real memory/primary memory).
*   **I/O Modules**: Move data between the computer and the external environment (secondary memory, communications, terminals).
*   **System Bus**: Provides communication among processors, main memory, and I/O modules. (Registers involved: PC, IR, MAR, MBR, I/O AR, I/O BR).

---

# Instruction Execution

## Program Execution Overview
*   A program is a set of instructions in memory.
*   The processor fetches and executes instructions.
*   Two stages: **Fetch Stage** and **Execute Stage** (the instruction cycle).

## Instruction Cycle: Fetch Stage
1.  **Processor fetches an instruction from memory.**
2.  **Program Counter (PC)** holds the address of the next instruction.
3.  **PC is incremented after each fetch.**
4.  The instruction is **loaded into the Instruction Register (IR)**.

## Instruction Cycle: Execute Stage
The processor interprets the instruction and performs the action:
*   **Processor-memory**: Data transfer between processor and memory.
*   **Processor-I/O**: Data transfer between processor and I/O module.
*   **Data processing**: Arithmetic or logical operations on data.
*   **Control**: Altering execution sequence (jumps, branches).

---

# Interrupts

## Interrupt Definition and Purpose
*   **Mechanism to interrupt normal processor sequencing.**
*   **Improves processor utilization.**  Avoids wasteful waiting for slow I/O devices.

## Classes of Interrupts
*   **Program**: Result of instruction execution (overflow, division by zero, illegal instruction, invalid memory access).
*   **Timer**: Generated by a timer; allows regular OS functions.
*   **I/O**: Signal from an I/O controller (operation completion or error).
*   **Hardware Failure**: Power failure, memory parity error.

## Transfer of Control via Interrupts
1.  Normal execution is interrupted.
2.  Control transfers to an **Interrupt Handler**.
3.  Interrupt is handled.
4.  Control may return to the interrupted program.

---

# Memory Hierarchy

## Design Constraints on Computer Memory
*   **Capacity (How much?)**:  Desire for large capacity.
*   **Speed (How fast?)**: Must keep up with the processor.
*   **Cost (How expensive?)**: Reasonable cost.

## Levels of the Memory Hierarchy
*   **Registers**: Fastest, highest cost/bit (inside processor).
*   **Cache**: Small, fast (exploits locality).  Multiple levels (L1, L2, L3) are common.
*   **Main Memory**: Primary storage (volatile). Larger, lower cost/bit than cache.
*   **Secondary Memory (Auxiliary Memory)**: External, nonvolatile (e.g., disks). Larger, lower cost/bit than main memory.
*   **Off-line Storage**: Removable media (tape, CD-ROM). Largest capacity, lowest cost/bit, slowest access.

## Memory Hierarchy Relationships
Moving *down* the hierarchy:
*   **Decreasing cost per bit**
*   **Increasing capacity**
*   **Increasing access time**
*   **Decreasing frequency of processor access**

## Principle of Locality
*   Memory references tend to cluster.
*   **Temporal Locality**:  Recently accessed items are likely to be accessed again soon.
*   **Spatial Locality**:  Items near recently accessed items are likely to be accessed soon.
*   Data is organized to minimize access time across memory levels.

---

# Cache Memory

## Purpose of Cache Memory
*   **Small, fast memory** between processor and main memory.
*   **Exploits locality** to reduce average memory access time.
*   Improves processing speed by holding frequently accessed data/instructions.

## Cache and Main Memory Interaction
*   Data transferred in **blocks**.
*   **Cache Hit**: Data found in cache (fast access).
*   **Cache Miss**: Data *not* in cache; block transferred from main memory to cache.

## Cache Organisation
*   Single-level or multi-level (L1, L2, L3).

## Cache Design Considerations
*   **Cache size**
*   **Block size**
*   **Mapping function**
*   **Replacement algorithm**
*   **Write policy**
*   **Number of cache levels**

---

# I/O Techniques

## Three Techniques for I/O Operations
*   **Programmed I/O**
*   **Interrupt-Driven I/O**
*   **Direct Memory Access (DMA)**

## Programmed I/O
*   Processor issues I/O command.
*   I/O module performs action, sets status bits.
*   **Processor periodically checks status.**
*   **Inefficient**: Processor wastes time waiting.

## Interrupt-Driven I/O
*   Processor issues I/O command, continues other work.
*   I/O module interrupts when ready.
*   Processor handles data transfer, resumes previous work.
*   More efficient than programmed I/O, but still requires processor intervention for each transfer.

## Direct Memory Access (DMA)
*   Processor issues command to DMA module:
    *   Read/Write
    *   I/O device address
    *   Memory start location
    *   Number of words
*   **DMA module transfers data directly to/from memory without processor involvement.**
*   Processor only involved at start and end.
*   **Most efficient**: Processor free for other tasks during transfer.

---

# Symmetric Multiprocessors (SMP)

## Characteristics of SMP
*   **Two or more similar processors** (comparable capability).
*   **Shared main memory**.
*   **Shared I/O devices**.
*   **Processors perform same functions**.
*   **Controlled by an integrated operating system**.

## Advantages of SMP
*   **Performance**: Increased performance through parallelism.
*   **Availability**: Failure of one processor doesn't halt the system.
*   **Incremental Growth**: Add processors for more performance.
*   **Scaling**: Vendors offer different price/performance options.

---

# Multicore Computers

## Definition of Multicore Systems
*   **Combines two or more processors (cores) on a single chip (die)**.  Also known as a chip multiprocessor.

## Core Components and Cache Levels
*   Each core is a full processor.
*   Typically includes shared L2 and sometimes L3 cache.

---

# Operating System Fundamentals

## Definition and Role of an Operating System
*   **Program that controls execution of application programs.**
*   **Interface between applications and hardware.** (See Figure 2.1 in the original text for a diagram)

## Main Objectives of an OS
*   **Convenience**: Easy to use.
*   **Efficiency**: Efficient resource management.
*   **Ability to Evolve**: Permits development/testing/introduction of new functions.

## OS and Hardware/Software Interaction
*   Interacts with hardware and software.
*   Provides **Application Programming Interface (API)**.
*   Manages **Instruction Set Architecture (ISA)**.

## Operating System Services
*   **Program development** (editors, compilers).
*   **Program execution**.
*   **Access I/O devices**.
*   **Controlled access to files**.
*   **System access** (security).
*   **Error detection and response**.
*   **Accounting**.
*   **Memory Management.**

---

# Evolution of Operating Systems

## Reasons for OS Evolution
*   **Hardware upgrades**.
*   **New types of hardware**.
*   **New services**.
*   **Fixes**.

## Stages of OS Evolution
*   **Serial Processing**: Direct user access, one program at a time.
*   **Simple Batch Systems**: Monitor program manages batch of jobs.
*   **Multiprogrammed Batch Systems**: Multiple programs in memory concurrently (improves utilization). (Figure 2.11 in the original text illustrates.)
*   **Time Sharing Systems**: Interactive computing, multiple users.

---

# Major Achievements in OS Development

Operating Systems are complex.  Major advances include:

## Processes
*   Fundamental concept.
*   Definitions:
    *   **Program in execution**.
    *   **Instance of a running program**.
    *   **Entity assigned to and executed on a processor**.
    *   **Unit of activity with a thread, state, and resources**.

## Memory Management
*   **Virtual memory**: Logical addressing, regardless of physical memory.
*   **Paging**: Processes divided into fixed-size pages; dynamic mapping.

## Information Protection and Security
*   Controlling access to system and information.
*   Maintain **availability**, **confidentiality**, **data integrity**, and **authenticity**.

## Scheduling and Resource Management
*   Allocating processor time, memory, I/O.
*   Policies consider **fairness**, **differential responsiveness**, and **efficiency**. (See Figure 2.11 from the original text.)

## System Structure
*   New approaches: **microkernel architecture**, **multithreading**, **symmetric multiprocessing**, **distributed operating systems**, **object-oriented design**.

---

# Process Management

## Definition of a Process
(See definitions under "Major Achievements").

## Causes of Errors in Concurrent Processes
*   **Nondeterminate program operation**: Unpredictable outcomes due to interleaving.
*   **Deadlocks**:  Processes blocked, waiting for each other.
*   **Improper synchronization**: Incorrect handling of signals.
*   **Failed mutual exclusion**: Simultaneous access to shared resources.

## Execution Context
*   **Essential for OS supervision and control.**
*   Includes:
    *   **Contents of process registers** (PC, general-purpose).
    *   **Process priority**, waiting status.
(Figure 2.8 from the original text illustrates.)

## Components of a Process
*   **Executable program (code)**.
*   **Associated data**.
*   **Execution context (process state)**.

---

# Memory Management

## Principal Storage Management Responsibilities
*   **Process isolation**.
*   **Automatic allocation and management**.
*   **Support of modular programming**.
*   **Protection and access control**.
*   **Long-term storage**.

## Virtual Memory
*   **Allows logical addressing independent of physical memory.**
*   Developed for multiple concurrent user jobs.

## Paging
*   Processes divided into **fixed-size pages**.
*   **Virtual address**: Page number + offset.
*   **Dynamic mapping** between virtual and real addresses (using the MMU). (Figures 2.9 and 2.10 in the original text illustrate.)

---

# Information Protection and Security

## Main Issues in Information Protection and Security
*   **Availability**:  Access to information and resources.
*   **Confidentiality**: Preventing unauthorized disclosure.
*   **Data integrity**: Protection from unauthorized modification.
*   **Authenticity**: Verifying identities and data sources.

---

# Scheduling and Resource Management

## Key Responsibility of an OS
*   **Managing resources** (processor, memory, I/O).

## Resource Allocation Policies
*   **Fairness**.
*   **Differential responsiveness**.
*   **Efficiency**.
 (See Figure 2.11 from the original text.)

---

# Different Architectural Approaches for OS

## Microkernel Architecture
*   **Few essential functions in the kernel** (address spaces, IPC, basic scheduling).
*   Other services as user-level processes.
*   **Benefits**: Simplicity, flexibility, distributed environment suitability.

## Multithreading
*   **Process divided into concurrently runnable threads.**
*   **Thread**: Dispatchable unit of work (context, stack).
*   **Process**: One or more threads + resources.
*   Improved modularity and timing control.

## Symmetric Multiprocessing (SMP)
*   **Computer hardware architecture and OS behavior.**
*   **OS schedules threads/processes across all processors.**
*   **Transparency to the user.**
*   **Advantages**: Performance, availability, growth, scaling. (Figure 2.12 from the original text shows uniprocessor vs multiprocessor.)

## Distributed Operating Systems
*   Illusion of single memory/storage space, unified access.
*   More complex than uniprocessor/SMP OS.

## Object-Oriented Design
*   Modular extensions to a small kernel.
*   Customization without disruption.
*   Eases distributed tool/OS development.

---

# Multithreading (Architectural Approach Details)

## Threads vs. Processes
(See definitions above).

## Benefits of Multithreading
*   **Modularity**.
*   **Finer-grained timing control**.
*   Shared memory/resources within a process (efficiency).

---

# Symmetric Multiprocessing (Architectural Approach Details)

## OS Role in SMP Systems
*   **Scheduling** across processors.
*   **Synchronization**.
*   **Load balancing**.
*   **Resource management**.

## Transparency to the User
*   Parallelism managed by OS.

---
# Distributed Operating System (Details)

*   Single system image across multiple computers.
*   Distributed file system.
*   Resource Sharing.
*   More Complex.

---
# Fault Tolerance

## Definition and Purpose of Fault Tolerance
*   **System continues operating despite hardware/software faults.**
*   Involves **redundancy**.
*   **Increases reliability**.

## Costs Associated with Fault Tolerance
*   **Financial cost or performance impact**.
*   Extent of adoption depends on criticality.

---

# Fundamental Concepts of Fault Tolerance

## Reliability
*   **R(t)**: Probability of correct operation up to time *t*, given correct operation at *t*=0.

## Mean Time To Failure (MTTF) and Mean Time To Repair (MTTR)
*   **MTTF**: Average time to failure.
*   **MTTR**: Average time to repair.

## Availability
*   Fraction of time system is available.
*   Availability = MTTF / (MTTF + MTTR)

## Availability Classes
(Based on percentage of uptime, resulting annual downtime)
*   **Continuous**: 1.0 (0 downtime).
*   **Fault Tolerant**: 0.99999 (5 minutes).
*   **Fault Resilient**: 0.9999 (53 minutes).
*   **High Availability**: 0.999 (8.3 hours).
*   **Normal Availability**: 0.99 - 0.995 (44-87 hours).

---

# Faults

## Definition and Causes of Faults
(IEEE Standards Dictionary) Erroneous hardware/software state due to:
*   Component failure
*   Operator error
*   Environmental interference
*   Design error
*   Program error
*   Data structure error

A fault manifests as a **defect**.

## Permanent Faults
*   **Always present** after occurrence.
*   Requires component replacement/repair.

## Temporary Faults
*   **Not always present**.
    *   **Transient**: Occurs only once.
    *   **Intermittent**: Occurs multiple, unpredictable times.

---

# Methods of Redundancy

## Spatial (Physical) Redundancy
*   **Multiple components** (same function or backup).
*   Examples: Dual systems, TMR, spares.

## Temporal Redundancy
*   **Repeating a function/operation.**
*   Effective for **temporary faults**.
*   Not useful for permanent faults.
*   Examples: Retry, re-execute.

## Information Redundancy
*   **Replicating or coding data** for error detection/correction.
*   Examples: Parity bits, checksums, error-correcting codes.